<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Feature Chain Parser - mloda docs</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Feature Chain Parser";
        var mkdocs_page_input_path = "in_depth/feature-chain-parser.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> mloda docs
        </a>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Home</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../..">mloda</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">mloda Concepts</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../examples/mloda_basics/0_table_of_content/">Table of Content</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../examples/mloda_basics/1_ml_mloda_intro/">Intro to the core interfaces of mloda</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../examples/mloda_basics/2_ml_advantage_process_focus/">What makes mloda unique?</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../examples/mloda_basics/3_ml_data_feature_feature_groups/">Data, Feature, FeatureSets and FeatureGroups in mloda</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../examples/mloda_basics/4_ml_data_providers_user_steward/">Provider, User, Steward in mloda</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Getting Started</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter1/installation/">Installation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../examples/sklearn_integration_basic/">mloda + scikit-learn Integration: Basic Example</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter1/api-request/">API Request</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter1/feature-groups/">Feature Groups</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter1/compute-frameworks/">Compute Frameworks</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter1/extender/">Extender</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">In Depth - Basics</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../mloda-api/">mloda API</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../access-feature-data/">(Feature) data</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../join_data/">Join data</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../filter_data/">Filter data</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../artifacts/">Artifacts</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">In Depth - Advanced</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../data-quality/">Data quality</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../domain/">Domain concept</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../data-access-patterns/">Data Access Patterns</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Compute Frameworks</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../framework-transformers/">Framework Transformers</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../compute-framework-integration/">Compute Framework Integration</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../framework-connection-object/">Framework Connection Object</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" >Feature Groups</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../feature-config/">Feature Configuration</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="#">Feature Chain Parser</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#key-concepts">Key Concepts</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#separator-system">Separator System</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#feature-chaining">Feature Chaining</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#multi-feature-input">Multi-Feature Input</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unified-parser-architecture">Unified Parser Architecture</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#options-architecture-group-vs-context-parameters">Options Architecture: Group vs Context Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#configuration-based-feature-creation">Configuration-Based Feature Creation</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#featurechainparsermixin">FeatureChainParserMixin</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#basic-usage">Basic Usage</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#mixin-configuration">Mixin Configuration</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#customization-hooks">Customization Hooks</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#modern-implementation-in-feature-groups">Modern Implementation in Feature Groups</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1-define-property_mapping-configuration">1. Define PROPERTY_MAPPING Configuration</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2-update-match_feature_group_criteria">2. Update match_feature_group_criteria</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#3-modernize-input_features-method">3. Modernize input_features Method</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#4-update-calculate_feature-method">4. Update calculate_feature Method</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#5-advanced-property_mapping-features">5. Advanced PROPERTY_MAPPING Features</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#multiple-result-columns-with-pattern">Multiple Result Columns with ~ Pattern</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#producer-side-creating-multi-column-outputs">Producer Side: Creating Multi-Column Outputs</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#consumer-side-discovering-multi-column-features">Consumer Side: Discovering Multi-Column Features</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#manual-column-access-legacy">Manual Column Access (Legacy)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#benefits">Benefits</a>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../feature-group-matching/">Feature Group Matching</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../property-mapping/">PROPERTY_MAPPING</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../feature-group-testing/">Feature Group Testing</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../feature-group-version/">Feature Group Versioning</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../multiple_result_columns/">Multiple Result Columns</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Plugin System</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../plugin-loader/">Plugin Loader</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Troubleshooting</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../troubleshooting/feature-group-resolution-errors/">Feature Group Resolution Errors</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../development/">Contributors</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../license/">License - Apache 2.0</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../missing/">Missing</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Need Help?</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../faq/">FAQ</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../need-help/">Need Help</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">mloda docs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">In Depth - Advanced</li>
          <li class="breadcrumb-item">Feature Groups</li>
      <li class="breadcrumb-item active">Feature Chain Parser</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="feature-chain-parser">Feature Chain Parser</h1>
<h2 id="overview">Overview</h2>
<p>The Feature Chain Parser system enables feature groups to work with both traditional string-based feature names and modern configuration-based feature creation. This unified approach provides flexibility while maintaining backward compatibility.</p>
<blockquote>
<p><strong>For AI Agents:</strong> Feature chaining enables LLMs to declare complex data pipelines through simple naming conventions. Instead of writing pipeline code, agents can request <code>user_query__validated__retrieved__pii_redacted</code> - mloda resolves the full chain automatically.</p>
</blockquote>
<h2 id="key-concepts">Key Concepts</h2>
<h3 id="separator-system">Separator System</h3>
<p>mloda uses three separator characters in feature names, each with a specific purpose:</p>
<table>
<thead>
<tr>
<th>Separator</th>
<th>Constant</th>
<th>Purpose</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__</code></td>
<td><code>CHAIN_SEPARATOR</code></td>
<td>Separates chained transformations (sourceâ†’suffix)</td>
<td><code>price__mean_imputed</code></td>
</tr>
<tr>
<td><code>~</code></td>
<td><code>COLUMN_SEPARATOR</code></td>
<td>Separates multi-column output index</td>
<td><code>feature__pca~0</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td><code>INPUT_SEPARATOR</code></td>
<td>Separates multiple input features</td>
<td><code>point1&amp;point2__distance</code></td>
</tr>
</tbody>
</table>
<p>These constants are available from the <code>mloda.provider</code> facade:</p>
<pre><code class="language-python">from mloda.provider import (
    CHAIN_SEPARATOR,    # &quot;__&quot;
    COLUMN_SEPARATOR,   # &quot;~&quot;
    INPUT_SEPARATOR,    # &quot;&amp;&quot;
)
</code></pre>
<h3 id="feature-chaining">Feature Chaining</h3>
<p>Feature chaining allows feature groups to be composed, where the output of one feature group becomes the input to another. This is reflected in the feature name using the chain separator (<code>__</code>):</p>
<pre><code>{in_feature}__{operation}
</code></pre>
<p>For example:
- <code>sales__sum_aggr</code> - Simple feature
- <code>price__mean_imputed__sum_7_day_window__max_aggr</code> - Chained feature</p>
<h3 id="multi-feature-input">Multi-Feature Input</h3>
<p>Some feature groups require multiple input features. These are separated using the input separator (<code>&amp;</code>):</p>
<pre><code>{feature1}&amp;{feature2}__{operation}
</code></pre>
<p>For example:
- <code>point1&amp;point2__haversine_distance</code> - GeoDistance with two points
- <code>age&amp;income&amp;score__cluster_kmeans_3</code> - Clustering with multiple features</p>
<h3 id="unified-parser-architecture">Unified Parser Architecture</h3>
<p>The modernized <code>FeatureChainParser</code> provides a unified approach through the <code>match_configuration_feature_chain_parser</code> method that handles:</p>
<ul>
<li><strong>String-based features</strong>: Traditional pattern matching with regex</li>
<li><strong>Configuration-based features</strong>: Modern approach using Options and PROPERTY_MAPPING</li>
<li><strong>Dual validation</strong>: Features can be validated using either or both approaches</li>
</ul>
<h3 id="options-architecture-group-vs-context-parameters">Options Architecture: Group vs Context Parameters</h3>
<p>The new <code>Options</code> class separates parameters into two categories:</p>
<ul>
<li><strong>Group Parameters</strong>: Affect Feature Group resolution and splitting (stored in <code>options.group</code>)</li>
<li><strong>Context Parameters</strong>: Metadata that doesn't affect splitting (stored in <code>options.context</code>)</li>
</ul>
<pre><code class="language-python">from mloda.user import Options
from typing import Optional

# New Options architecture
options = Options(
    group={
        &quot;data_source&quot;: &quot;production&quot;,  # Affects Feature Group splitting
    },
    context={
        &quot;aggregation_type&quot;: &quot;sum&quot;,    # Doesn't affect splitting
        &quot;in_features&quot;: &quot;sales&quot;
    }
)
</code></pre>
<h3 id="configuration-based-feature-creation">Configuration-Based Feature Creation</h3>
<p>Modern feature creation uses the Options architecture:</p>
<pre><code class="language-python">from mloda.user import Feature, Options

# Traditional string-based approach:
feature = Feature(&quot;sales__sum_aggr&quot;)

# Modern configuration-based approach:
feature = Feature(
    &quot;placeholder&quot;,  # Will be replaced during processing
    Options(
        context={
            &quot;aggregation_type&quot;: &quot;sum&quot;,
            &quot;in_features&quot;: &quot;sales&quot;
        }
    )
)
</code></pre>
<h2 id="featurechainparsermixin">FeatureChainParserMixin</h2>
<p>The <code>FeatureChainParserMixin</code> provides default implementations for common feature chain parsing operations. Feature groups that use feature chaining should inherit from this mixin to reduce boilerplate code.</p>
<h3 id="basic-usage">Basic Usage</h3>
<pre><code class="language-python">from mloda.provider import FeatureGroup, FeatureChainParserMixin
from mloda_plugins.feature_group.experimental.default_options_key import DefaultOptionKeys

class MyFeatureGroup(FeatureChainParserMixin, FeatureGroup):
    PREFIX_PATTERN = r&quot;.*__my_operation$&quot;

    # In-feature constraints
    MIN_IN_FEATURES = 1
    MAX_IN_FEATURES = 1  # Or None for unlimited

    PROPERTY_MAPPING = {
        &quot;operation_type&quot;: {
            &quot;sum&quot;: &quot;Sum operation&quot;,
            &quot;avg&quot;: &quot;Average operation&quot;,
            DefaultOptionKeys.mloda_context: True,
        },
        DefaultOptionKeys.in_features: {
            &quot;explanation&quot;: &quot;Source feature&quot;,
            DefaultOptionKeys.mloda_context: True,
        },
    }

    # input_features() inherited from FeatureChainParserMixin
    # match_feature_group_criteria() inherited from FeatureChainParserMixin
</code></pre>
<h3 id="mixin-configuration">Mixin Configuration</h3>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PREFIX_PATTERN</code></td>
<td><code>str</code></td>
<td>Required</td>
<td>Regex pattern for matching feature names</td>
</tr>
<tr>
<td><code>PROPERTY_MAPPING</code></td>
<td><code>dict</code></td>
<td>Required</td>
<td>Parameter validation configuration</td>
</tr>
<tr>
<td><code>MIN_IN_FEATURES</code></td>
<td><code>int</code></td>
<td><code>1</code></td>
<td>Minimum required in_features</td>
</tr>
<tr>
<td><code>MAX_IN_FEATURES</code></td>
<td><code>int \| None</code></td>
<td><code>None</code></td>
<td>Maximum allowed in_features (None = unlimited)</td>
</tr>
<tr>
<td><code>IN_FEATURE_SEPARATOR</code></td>
<td><code>str</code></td>
<td><code>"&amp;"</code></td>
<td>Separator for multiple in_features</td>
</tr>
</tbody>
</table>
<h3 id="customization-hooks">Customization Hooks</h3>
<h4 id="1-custom-validation-with-_validate_string_match">1. Custom Validation with <code>_validate_string_match()</code></h4>
<p>Override this hook when you need custom validation for string-based feature names:</p>
<pre><code class="language-python">class ClusteringFeatureGroup(FeatureChainParserMixin, FeatureGroup):
    @classmethod
    def _validate_string_match(cls, feature_name: str, operation_config: str, in_feature: str) -&gt; bool:
        &quot;&quot;&quot;Validate clustering-specific patterns.&quot;&quot;&quot;
        if FeatureChainParser.is_chained_feature(feature_name):
            try:
                cls.parse_clustering_prefix(feature_name)
            except ValueError:
                return False
        return True
</code></pre>
<h4 id="2-custom-input_features-method">2. Custom <code>input_features()</code> Method</h4>
<p>Override when you need to add additional input features (e.g., time filter):</p>
<pre><code class="language-python">class TimeWindowFeatureGroup(FeatureChainParserMixin, FeatureGroup):
    def input_features(self, options: Options, feature_name: FeatureName) -&gt; Optional[Set[Feature]]:
        # Try string-based parsing first
        _, in_feature = FeatureChainParser.parse_feature_name(feature_name.name, [self.PREFIX_PATTERN])
        if in_feature is not None:
            time_filter_feature = Feature(self.get_reference_time_column(options))
            return {Feature(in_feature), time_filter_feature}

        # Fall back to configuration-based approach
        in_features = options.get_in_features()
        time_filter_feature = Feature(self.get_reference_time_column(options))
        return set(in_features) | {time_filter_feature}
</code></pre>
<h4 id="3-custom-match_feature_group_criteria-method">3. Custom <code>match_feature_group_criteria()</code> Method</h4>
<p>Override for complex pre-check logic that can't be captured by the hook:</p>
<pre><code class="language-python">class SklearnPipelineFeatureGroup(FeatureChainParserMixin, FeatureGroup):
    @classmethod
    def match_feature_group_criteria(cls, feature_name, options, data_access_collection=None) -&gt; bool:
        &quot;&quot;&quot;Custom matching with mutual exclusivity validation.&quot;&quot;&quot;
        has_pipeline_name = options.get(cls.PIPELINE_NAME)
        has_pipeline_steps = options.get(cls.PIPELINE_STEPS)

        # Pre-check: require pattern in name if no config provided
        if has_pipeline_name is None and has_pipeline_steps is None:
            if &quot;sklearn_pipeline_&quot; not in str(feature_name):
                return False

        # Use base matching
        base_match = FeatureChainParser.match_configuration_feature_chain_parser(...)

        # Post-check: mutual exclusivity
        if base_match and has_pipeline_name and has_pipeline_steps:
            return False
        return base_match
</code></pre>
<h2 id="modern-implementation-in-feature-groups">Modern Implementation in Feature Groups</h2>
<h3 id="1-define-property_mapping-configuration">1. Define PROPERTY_MAPPING Configuration</h3>
<p>The modern approach uses <code>PROPERTY_MAPPING</code> to define parameter validation and classification:</p>
<pre><code class="language-python">from mloda.provider import FeatureGroup
from mloda.user import FeatureName
from mloda_plugins.feature_group.experimental.default_options_key import DefaultOptionKeys

class MyFeatureGroup(FeatureGroup):
    PREFIX_PATTERN = r&quot;__([a-zA-Z_]+)_operation$&quot;

    PROPERTY_MAPPING = {
        # Feature-specific parameter
        &quot;operation_type&quot;: {
            &quot;sum&quot;: &quot;Sum aggregation&quot;,
            &quot;avg&quot;: &quot;Average aggregation&quot;, 
            &quot;max&quot;: &quot;Maximum aggregation&quot;,
            DefaultOptionKeys.context: True,  # Context parameter
            DefaultOptionKeys.strict_validation: True,  # Strict validation
        },
        # Source feature parameter
        DefaultOptionKeys.in_features: {
            &quot;explanation&quot;: &quot;Source feature for the operation&quot;,
            DefaultOptionKeys.context: True,  # Context parameter
            DefaultOptionKeys.strict_validation: False,  # Flexible validation
        },
    }
</code></pre>
<h3 id="2-update-match_feature_group_criteria">2. Update match_feature_group_criteria</h3>
<p>Replace old pattern-only matching with unified parser:</p>
<pre><code class="language-python">@classmethod
def match_feature_group_criteria(cls, feature_name, options, data_access_collection=None):
    return FeatureChainParser.match_configuration_feature_chain_parser(
        feature_name,
        options,
        property_mapping=cls.PROPERTY_MAPPING,
        prefix_patterns=[cls.PREFIX_PATTERN],
    )
</code></pre>
<h3 id="3-modernize-input_features-method">3. Modernize input_features Method</h3>
<p>Handle both string-based and configuration-based features:</p>
<pre><code class="language-python">def input_features(self, options: Options, feature_name: FeatureName) -&gt; Optional[Set[Feature]]:
    &quot;&quot;&quot;Extract source feature from either configuration-based options or string parsing.&quot;&quot;&quot;

    # Try string-based parsing first
    _, in_feature = FeatureChainParser.parse_feature_name(
        feature_name, [self.PREFIX_PATTERN]
    )
    if in_feature is not None:
        return {Feature(in_feature)}

    # Fall back to configuration-based approach
    in_features = options.get_in_features()
    if len(in_features) != 1:
        raise ValueError(
            f&quot;Expected exactly one in_feature, but found {len(in_features)}: {in_features}&quot;
        )
    return set(in_features)
</code></pre>
<h3 id="4-update-calculate_feature-method">4. Update calculate_feature Method</h3>
<p>Support dual approach in feature processing:</p>
<pre><code class="language-python">def calculate_feature(self, features, options):
    for feature in features.features:
        # Try configuration-based approach first
        try:
            in_features = feature.options.get_in_features()
            in_feature = next(iter(in_features))
            in_feature_name = in_feature.get_name()

            # Extract parameters from options
            operation_type = feature.options.get(&quot;operation_type&quot;)

        except (ValueError, StopIteration):
            # Fall back to string-based approach for legacy features
            operation_type, in_feature_name = FeatureChainParser.parse_feature_name(
                feature.name, [cls.PREFIX_PATTERN]
            )

        # Process using extracted values
        # ... implementation logic
</code></pre>
<h3 id="5-advanced-property_mapping-features">5. Advanced PROPERTY_MAPPING Features</h3>
<h4 id="validation-functions">Validation Functions</h4>
<p>For complex validation beyond simple value lists:</p>
<pre><code class="language-python">PROPERTY_MAPPING = {
    &quot;dimension&quot;: {
        &quot;explanation&quot;: &quot;Number of dimensions for reduction&quot;,
        DefaultOptionKeys.context: True,
        DefaultOptionKeys.strict_validation: True,
        DefaultOptionKeys.validation_function: lambda x: isinstance(x, int) and x &gt; 0,
    },
}
</code></pre>
<h4 id="default-values">Default Values</h4>
<p>Specify default values for optional parameters:</p>
<pre><code class="language-python">PROPERTY_MAPPING = {
    &quot;window_size&quot;: {
        &quot;7&quot;: &quot;7-day window&quot;,
        &quot;30&quot;: &quot;30-day window&quot;,
        DefaultOptionKeys.default: &quot;7&quot;,  # Default value
        DefaultOptionKeys.context: True,
    },
}
</code></pre>
<h4 id="group-vs-context-classification">Group vs Context Classification</h4>
<pre><code class="language-python">PROPERTY_MAPPING = {
    # Group parameter - affects Feature Group resolution
    &quot;data_source&quot;: {
        &quot;production&quot;: &quot;Production data&quot;,
        &quot;staging&quot;: &quot;Staging data&quot;, 
        DefaultOptionKeys.group: True,  # Explicit group parameter
        DefaultOptionKeys.strict_validation: True,
    },
    # Context parameter - doesn't affect resolution
    &quot;algorithm_type&quot;: {
        &quot;kmeans&quot;: &quot;K-means clustering&quot;,
        &quot;dbscan&quot;: &quot;DBSCAN clustering&quot;,
        DefaultOptionKeys.context: True,  # Context parameter
        DefaultOptionKeys.strict_validation: False,  # Flexible validation
    },
}
</code></pre>
<h2 id="multiple-result-columns-with-pattern">Multiple Result Columns with ~ Pattern</h2>
<p>Some feature groups produce multiple result columns from a single input feature. mloda provides utilities to work with these patterns seamlessly.</p>
<h3 id="producer-side-creating-multi-column-outputs">Producer Side: Creating Multi-Column Outputs</h3>
<p>Use <code>apply_naming_convention()</code> to create properly named columns:</p>
<pre><code class="language-python">from mloda.provider import FeatureGroup, FeatureSet

class MultiColumnProducer(FeatureGroup):
    @classmethod
    def calculate_feature(cls, data: Any, features: FeatureSet) -&gt; Any:
        # Compute results (e.g., from sklearn OneHotEncoder)
        result = encoder.transform(data)  # Returns 2D numpy array (n_samples, n_features)

        # Automatically apply naming convention
        feature_name = features.get_name_of_one_feature().name
        named_columns = cls.apply_naming_convention(result, feature_name)
        # Returns: {&quot;category__onehot_encoded~0&quot;: data, &quot;~1&quot;: data, &quot;~2&quot;: data}

        return named_columns
</code></pre>
<h3 id="consumer-side-discovering-multi-column-features">Consumer Side: Discovering Multi-Column Features</h3>
<p>Use <code>resolve_multi_column_feature()</code> to automatically discover columns:</p>
<pre><code class="language-python">class MultiColumnConsumer(FeatureGroup):
    def input_features(self, options: Options, feature_name: FeatureName) -&gt; Optional[Set[Feature]]:
        # Request base feature without ~N suffix
        return {Feature(&quot;category__onehot_encoded&quot;)}

    @classmethod
    def calculate_feature(cls, data: Any, features: FeatureSet) -&gt; Any:
        # Automatically discover all matching columns
        columns = cls.resolve_multi_column_feature(
            &quot;category__onehot_encoded&quot;,
            set(data.columns)
        )
        # Returns: [&quot;category__onehot_encoded~0&quot;, &quot;~1&quot;, &quot;~2&quot;]

        # Process all discovered columns
        result = sum(data[col] for col in columns)

        feature_name = features.get_name_of_one_feature().name
        return {feature_name: result}
</code></pre>
<h3 id="manual-column-access-legacy">Manual Column Access (Legacy)</h3>
<p>For backwards compatibility, you can still access specific columns:</p>
<pre><code class="language-python"># Manual specification of specific columns
base_feature = &quot;category__onehot_encoded&quot;  # Creates all columns
specific_column = &quot;category__onehot_encoded~0&quot;  # Access first column
another_column = &quot;category__onehot_encoded~1&quot;  # Access second column
</code></pre>
<p><strong>Recommended</strong>: Use automatic discovery (<code>resolve_multi_column_feature</code>) instead of manual enumeration for cleaner, more maintainable code.</p>
<h2 id="benefits">Benefits</h2>
<ul>
<li><strong>Consistent Naming</strong>: Enforces naming conventions across feature groups</li>
<li><strong>Composability</strong>: Enables building complex features through chaining</li>
<li><strong>Configuration-Based Creation</strong>: Simplifies feature creation in client code</li>
<li><strong>Validation</strong>: Ensures feature names follow expected patterns</li>
<li><strong>Multi-Column Support</strong>: Handle transformations that produce multiple result columns</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../feature-config/" class="btn btn-neutral float-left" title="Feature Configuration"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../feature-group-matching/" class="btn btn-neutral float-right" title="Feature Group Matching">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../feature-config/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../feature-group-matching/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
